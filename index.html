<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sonic Wallet NFT Scanner (from curated contract list)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ethers v6 UMD (global window.ethers) + fallback -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
  <script>
    if (typeof window.ethers === "undefined") {
      var s = document.createElement("script");
      s.src = "https://unpkg.com/ethers@6.11.1/dist/ethers.umd.min.js";
      document.head.appendChild(s);
    }
  </script>

  <style>
    :root { --bg:#0b0e13; --panel:#131823; --txt:#e6e9ef; --muted:#9aa3b2; --accent:#66e7ff; --danger:#ff6b6b; --line:#202636; }
    * { box-sizing: border-box; }
    body { margin:0; font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--txt); }
    .wrap { max-width: 1060px; margin: 2rem auto; padding: 0 1rem; }
    h1 { font-size:1.6rem; margin:.25rem 0 .5rem; }
    .muted { color:var(--muted); }
    .small { font-size:.9rem; }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:1rem; }
    label { display:block; font-size:.9rem; color:var(--muted); margin:.75rem 0 .25rem; }
    input[type="text"], input[type="number"] { width:100%; padding:.7rem .8rem; border:1px solid #263044; border-radius:10px; background:#0f1420; color:var(--txt); }
    .row { display:grid; grid-template-columns: 1fr auto auto; gap:.75rem; align-items:end; }
    .row-adv { display:grid; grid-template-columns: repeat(4, minmax(140px, 1fr)); gap:.75rem; margin-top:.75rem; }
    button { padding:.75rem 1rem; background:var(--accent); color:#00242b; border:0; border-radius:10px; font-weight:600; cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .cols { display:grid; gap:1rem; grid-template-columns: 1.1fr .9fr; margin-top:1rem; }
    .list { min-height: 240px; border:1px dashed #2b3448; border-radius:10px; padding:.75rem; overflow:auto; }
    .error { color:var(--danger); margin-top:.5rem; white-space:pre-wrap; }
    @media (max-width: 980px){ .cols { grid-template-columns: 1fr; } .row { grid-template-columns: 1fr auto; } .row-adv { grid-template-columns: 1fr 1fr; } }
    .token { padding:.5rem .6rem; border:1px solid #263044; border-radius:8px; margin-bottom:.5rem; cursor:pointer; }
    .token:hover { border-color:#345; background:#0f1420; }
    .hdr { display:flex; align-items:center; justify-content:space-between; gap:.5rem; }
    .pill { display:inline-block; background:#0f1420; border:1px solid #263044; border-radius:999px; padding:.1rem .5rem; font-size:.75rem; color:#9fc2ca; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    progress { width: 100%; height: 10px; }
    a { color:#86f0ff; text-decoration:none; } a:hover { text-decoration:underline; }
    .kv { display:flex; flex-wrap:wrap; gap:.5rem; }
    .kv .item { background:#0f1420; border:1px solid #263044; border-radius:8px; padding:.2rem .5rem; font-size:.8rem; color:#b8c3d1; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Sonic Wallet NFT Scanner</h1>
      <p class="muted small">
        Uses a curated list of Sonic NFT collection contracts (<code class="mono">./data/sonic_nft_collections.json</code>) to scan a wallet quickly.
        RPC is fixed to <code class="mono">https://rpc.soniclabs.com</code>.
      </p>
    </header>

    <section class="card">
      <input type="hidden" id="rpcUrl" value="https://rpc.soniclabs.com" />

      <label for="wallet">Wallet address</label>
      <div class="row">
        <input id="wallet" class="mono" type="text" placeholder="0x… wallet address" autocomplete="off" />
        <button id="scanBtn">Scan</button>
        <button id="stopBtn" style="background:#ffd166;color:#3a2f00;">Stop</button>
      </div>

      <details style="margin-top:.5rem;">
        <summary class="muted small">List & Advanced</summary>
        <div class="row-adv">
          <div>
            <label for="listUrl">Contract list URL</label>
            <input id="listUrl" type="text" class="mono" value="./data/sonic_nft_collections.json" />
          </div>
          <div>
            <label for="chunkSize">Initial chunk (blocks)</label>
            <input id="chunkSize" class="mono" type="number" min="1000" step="1000" value="15000" />
          </div>
          <div>
            <label for="minChunk">Min chunk (blocks)</label>
            <input id="minChunk" class="mono" type="number" min="500" step="500" value="2000" />
          </div>
          <div>
            <label for="timeoutMs">Request timeout (ms)</label>
            <input id="timeoutMs" class="mono" type="number" min="5000" step="1000" value="25000" />
          </div>
        </div>
        <div class="kv" style="margin-top:.6rem;">
          <label class="item"><input id="respectStandard" type="checkbox" checked /> Respect “standard” from JSON (faster)</label>
          <label class="item"><input id="inferIfMissing" type="checkbox" checked /> If missing, scan both 721 & 1155</label>
          <label class="item"><input id="verify165" type="checkbox" /> Try ERC‑165 if no hits (slower)</label>
          <label class="item"><input id="limitContracts" type="checkbox" /> Limit to first N (<input id="limitN" type="number" value="100" class="mono" style="width:80px;">)</label>
        </div>
      </details>

      <div style="margin-top:.5rem;">
        <progress id="prog" max="100" value="0"></progress>
      </div>

      <div id="status" class="muted small" style="margin-top:.5rem;"></div>
      <div id="error" class="error" role="alert"></div>
    </section>

    <section class="cols">
      <div class="card">
        <div class="hdr" style="margin-bottom:.5rem;">
          <h3 style="margin:0;">Tokens Found</h3>
          <span id="foundPill" class="pill">0 collections</span>
        </div>
        <div id="tokens" class="list muted small">Load a list and scan a wallet.</div>
      </div>

      <div class="card">
        <div class="hdr" style="margin-bottom:.5rem;">
          <h3 style="margin:0;">Selected token</h3>
          <span id="selPill" class="pill">—</span>
        </div>
        <div id="selected" class="list muted small">Select a collection to view all tokens the wallet holds for it.</div>
      </div>
    </section>
  </div>

  <script>
    // ---------- Utilities ----------
    const $ = (id) => document.getElementById(id);
    const setStatus = (m) => $("status").textContent = m || "";
    const setError  = (m) => $("error").textContent  = m || "";
    const clearMsgs = () => { setStatus(""); setError(""); };
    const fmt = (n) => new Intl.NumberFormat().format(n);
    const mono = (s) => `<span class="mono">${s}</span>`;
    let CANCEL = false;

    // ---------- Provider ----------
    function getProvider(){ return new window.ethers.JsonRpcProvider($("rpcUrl").value.trim()); }

    // ---------- Topics & Interfaces ----------
    const TOPIC_ERC721_TRANSFER = window.ethers.id("Transfer(address,address,uint256)");
    const TOPIC_ERC1155_SINGLE  = window.ethers.id("TransferSingle(address,address,address,uint256,uint256)");
    const TOPIC_ERC1155_BATCH   = window.ethers.id("TransferBatch(address,address,address,uint256[],uint256[])");
    const iface1155 = new window.ethers.Interface([
      "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)",
      "event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)",
      "function supportsInterface(bytes4) view returns (bool)"
    ]);
    const IFACE_721  = "0x80ac58cd";
    const IFACE_1155 = "0xd9b67a26";

    const toTopicAddress = (addr) => window.ethers.zeroPadValue(window.ethers.getAddress(addr), 32);

    // ---------- Adaptive getLogs ----------
    function withTimeout(promise, ms) {
      return Promise.race([
        promise,
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), ms))
      ]);
    }

    async function getLogsAdaptive(provider, baseFilter, from, to, maxSpan, minSpan, timeoutMs) {
      const out = [];
      let start = from;
      while (start <= to) {
        if (CANCEL) break;
        let span = Math.min(maxSpan, to - start + 1);
        let done = false;
        while (!done && !CANCEL) {
          const end = start + span - 1;
          try {
            const logs = await withTimeout(provider.getLogs({ ...baseFilter, fromBlock: start, toBlock: end }), timeoutMs);
            out.push(...logs);
            done = true;
          } catch (e) {
            const msg = (e?.info?.error?.message || e?.message || String(e)).toLowerCase();
            const tooBig = msg.includes("more than") || msg.includes("too many") || msg.includes("response size") || msg.includes("result set") || msg.includes("limit");
            const timed  = msg.includes("timeout") || msg.includes("timed out") || msg.includes("exceeded") || msg.includes("deadline");
            if ((tooBig || timed) && span > minSpan) {
              span = Math.max(minSpan, Math.floor(span / 2));
              continue;
            }
            // Log & skip this slice
            console.warn("Skip subrange", {start, end, msg:e?.message || e});
            done = true;
          }
        }
        start += Math.min(span, to - start + 1);
      }
      return out;
    }

    // ---------- Load contract list ----------
    async function loadContractList(url){
      try {
        const resp = await fetch(url, { cache: "no-store" });
        const data = await resp.json();
        // Normalise to [{address, standard?}]
        const list = [];
        const push = (addr, standard, mints) => {
          try {
            const a = window.ethers.getAddress(addr);
            list.push({ address: a, standard: (standard || "Unknown"), mints: mints ?? 0 });
          } catch {}
        };
        if (Array.isArray(data)) {
          for (const item of data) {
            if (typeof item === "string") push(item);
            else if (item && typeof item === "object" && item.address) push(item.address, item.standard, item.mints);
          }
        }
        // De‑dupe by address (case-insensitive)
        const seen = new Map();
        for (const it of list) {
          const key = it.address.toLowerCase();
          if (!seen.has(key)) seen.set(key, it);
          else {
            // prefer entries with known standard
            const old = seen.get(key);
            if (old.standard === "Unknown" && it.standard !== "Unknown") seen.set(key, it);
          }
        }
        return Array.from(seen.values());
      } catch (e) {
        throw new Error("Failed to load or parse the contract list JSON. Check path & CORS.");
      }
    }

    // ---------- Wallet scan over contract list ----------
    async function scanWalletOverList() {
      clearMsgs();
      $("tokens").classList.remove("muted"); $("tokens").textContent = "";
      $("selected").textContent = "Scanning…"; $("selPill").textContent = "—";
      $("foundPill").textContent = "0 collections";
      $("prog").value = 0; CANCEL = false;

      const scanBtn = $("scanBtn"), stopBtn = $("stopBtn");
      scanBtn.disabled = true; stopBtn.disabled = false;

      // Validate wallet
      const walletRaw = $("wallet").value.trim();
      if (!/^0x[a-fA-F0-9]{40}$/.test(walletRaw)) {
        setError("Please enter a valid EVM address (0x…40 hex chars).");
        scanBtn.disabled = false; stopBtn.disabled = true;
        return;
      }
      const wallet = window.ethers.getAddress(walletRaw);
      const walletTopic = toTopicAddress(wallet);

      // Load list
      const listUrl = $("listUrl").value.trim() || "./data/sonic_nft_collections.json";
      setStatus(`Loading contract list from ${listUrl}…`);
      let contracts = await loadContractList(listUrl).catch(e => { setError(e.message || "List load error."); return null; });
      if (!contracts) { scanBtn.disabled = false; stopBtn.disabled = true; return; }

      // Optional limit (for testing)
      if ($("limitContracts").checked) {
        const n = Math.max(1, parseInt($("limitN").value || "100", 10));
        contracts = contracts.slice(0, n);
      }

      if (contracts.length === 0) {
        setError("The contract list is empty.");
        scanBtn.disabled = false; stopBtn.disabled = true; return;
      }

      setStatus(`Loaded ${fmt(contracts.length)} contracts. Preparing to scan wallet ${mono(wallet)}…`);

      const provider = getProvider();
      const latest = await provider.getBlockNumber().catch(e => { setError("RPC error getting latest block."); return null; });
      if (latest == null) { scanBtn.disabled = false; stopBtn.disabled = true; return; }

      const initChunk = Math.max(1000, parseInt($("chunkSize").value || "15000", 10));
      const minChunk  = Math.max(500,  parseInt($("minChunk").value || "2000", 10));
      const timeoutMs = Math.max(5000, parseInt($("timeoutMs").value || "25000", 10));
      const respectStd = $("respectStandard").checked;
      const inferIfMissing = $("inferIfMissing").checked;
      const verify165 = $("verify165").checked;

      const total = contracts.length;
      let done = 0;

      // Results
      const results = []; // {address, standard, ids:[{id, bal}]}

      // Limit concurrency to be nice to the RPC
      const CONCURRENCY = 3;
      const queue = contracts.map((c) => ({...c}));

      async function workOn(contract) {
        if (CANCEL) return;
        const addr = contract.address;
        let standard = (respectStd && contract.standard && contract.standard !== "Unknown") ? contract.standard : "Unknown";

        const baseFilter = { address: addr };
        const ownedTokens = new Map(); // id -> BigInt (1155 balance) or count for 721 (+1/-1)

        // helper reducers
        function apply721(logs) {
          for (const L of logs) {
            const fromTopic = L.topics[1];
            const toTopic   = L.topics[2];
            const tokenId   = window.ethers.toBigInt(L.topics[3]).toString();
            const cur = ownedTokens.get(tokenId) || 0;
            const from = "0x" + fromTopic.slice(26);
            const to   = "0x" + toTopic.slice(26);
            let next = cur;
            if (window.ethers.getAddress(from) === wallet) next -= 1;
            if (window.ethers.getAddress(to)   === wallet) next += 1;
            ownedTokens.set(tokenId, next);
          }
        }
        function apply1155Single(logs) {
          for (const L of logs) {
            const parsed = iface1155.decodeEventLog("TransferSingle", L.data, L.topics);
            const from = window.ethers.getAddress(parsed.from);
            const to   = window.ethers.getAddress(parsed.to);
            const id   = window.ethers.toBigInt(parsed.id).toString();
            const val  = window.ethers.toBigInt(parsed.value);
            const cur  = ownedTokens.get(id) || 0n;
            let next = cur;
            if (from === wallet) next -= val;
            if (to   === wallet) next += val;
            ownedTokens.set(id, next);
          }
        }
        function apply1155Batch(logs) {
          for (const L of logs) {
            const parsed = iface1155.decodeEventLog("TransferBatch", L.data, L.topics);
            const from = window.ethers.getAddress(parsed.from);
            const to   = window.ethers.getAddress(parsed.to);
            const ids  = parsed.ids.map(x => window.ethers.toBigInt(x).toString());
            const vals = parsed.values.map(x => window.ethers.toBigInt(x));
            for (let i=0;i<ids.length;i++){
              const id = ids[i], val = vals[i];
              const cur = ownedTokens.get(id) || 0n;
              let next = cur;
              if (from === wallet) next -= val;
              if (to   === wallet) next += val;
              ownedTokens.set(id, next);
            }
          }
        }

        // Scan logic per contract
        try {
          // If we know it's 721, only do 721 queries. If 1155, only 1155. If unknown and allowed, do both.
          const do721 = (standard === "ERC721") || (standard === "Unknown" && inferIfMissing);
          const do1155 = (standard === "ERC1155") || (standard === "Unknown" && inferIfMissing);

          // 721
          if (!CANCEL && do721) {
            const fFrom = { ...baseFilter, topics: [TOPIC_ERC721_TRANSFER, toTopicAddress(wallet), null] };
            const fTo   = { ...baseFilter, topics: [TOPIC_ERC721_TRANSFER, null, toTopicAddress(wallet)] };
            const [logsFrom, logsTo] = await Promise.all([
              getLogsAdaptive(provider, fFrom, 0, latest, initChunk, minChunk, timeoutMs),
              getLogsAdaptive(provider, fTo,   0, latest, initChunk, minChunk, timeoutMs)
            ]);
            apply721(logsFrom); apply721(logsTo);
          }

          // 1155
          if (!CANCEL && do1155) {
            // Single
            const fSFrom = { ...baseFilter, topics: [TOPIC_ERC1155_SINGLE, null, toTopicAddress(wallet), null] };
            const fSTo   = { ...baseFilter, topics: [TOPIC_ERC1155_SINGLE, null, null, toTopicAddress(wallet)] };
            const [sFrom, sTo] = await Promise.all([
              getLogsAdaptive(provider, fSFrom, 0, latest, initChunk, minChunk, timeoutMs),
              getLogsAdaptive(provider, fSTo,   0, latest, initChunk, minChunk, timeoutMs)
            ]);
            apply1155Single(sFrom); apply1155Single(sTo);

            // Batch
            const fBFrom = { ...baseFilter, topics: [TOPIC_ERC1155_BATCH, null, toTopicAddress(wallet), null] };
            const fBTo   = { ...baseFilter, topics: [TOPIC_ERC1155_BATCH, null, null, toTopicAddress(wallet)] };
            const [bFrom, bTo] = await Promise.all([
              getLogsAdaptive(provider, fBFrom, 0, latest, initChunk, minChunk, timeoutMs),
              getLogsAdaptive(provider, fBTo,   0, latest, initChunk, minChunk, timeoutMs)
            ]);
            apply1155Batch(bFrom); apply1155Batch(bTo);
          }

          // If nothing found and we had Unknown + verify165 → try to label for the future cache (optional UI path)
          if (!CANCEL && standard === "Unknown" && verify165) {
            try {
              const c = new window.ethers.Contract(addr, ["function supportsInterface(bytes4) view returns (bool)"], provider);
              const [is721, is1155] = await Promise.allSettled([ c.supportsInterface(IFACE_721), c.supportsInterface(IFACE_1155) ]);
              if (is721.status === "fulfilled" && is721.value) standard = "ERC721";
              else if (is1155.status === "fulfilled" && is1155.value) standard = "ERC1155";
            } catch {}
          }

          // Build result: keep only positive holdings
          let items = [];
          if ((standard === "ERC721") || (standard === "Unknown")) {
            // Interpret numeric values as counts; >0 => owned
            const owned = [];
            for (const [id, net] of ownedTokens.entries()) {
              if (typeof net === "number" && net > 0) owned.push({ id, bal: 1n }); // 721 effectively 1 per id
            }
            if (owned.length) items = owned;
          }
          if ((standard === "ERC1155") || (standard === "Unknown")) {
            const owned = [];
            for (const [id, bal] of ownedTokens.entries()) {
              if (typeof bal === "bigint" && bal > 0n) owned.push({ id, bal });
            }
            if (owned.length) items = owned;
          }

          if (items.length) {
            results.push({ address: addr, standard, ids: items });
          }
        } catch (e) {
          console.warn("Contract scan error", addr, e);
        } finally {
          done++;
          $("prog").value = Math.round((done / total) * 100);
          setStatus(`Scanned ${fmt(done)} / ${fmt(total)} contracts…`);
        }
      }

      const workers = Array.from({length: Math.min(CONCURRENCY, total)}, async () => {
        while (!CANCEL && queue.length) {
          const contract = queue.shift();
          await workOn(contract);
        }
      });
      await Promise.all(workers);

      if (CANCEL) {
        setStatus("Scan canceled.");
        scanBtn.disabled = false; stopBtn.disabled = true;
        return;
      }

      // Render results
      renderCollections(results, wallet, provider);

      setStatus(`Scan complete. Found ${fmt(results.length)} collection${results.length!==1?"s":""} with holdings.`);
      scanBtn.disabled = false; stopBtn.disabled = true;
    }

    function renderCollections(results, wallet, provider) {
      const tokensEl = $("tokens");
      tokensEl.textContent = "";
      if (!results.length) {
        tokensEl.classList.add("muted");
        tokensEl.textContent = "No NFTs found for this wallet in the provided contract list.";
        $("foundPill").textContent = "0 collections";
        $("selected").textContent = "—";
        $("selPill").textContent = "—";
        return;
      }

      $("foundPill").textContent = `${results.length} collection${results.length>1?"s":""}`;
      const chainIdPromise = provider.getNetwork().then(n => Number(n.chainId)).catch(()=>146);

      results
        .sort((a,b)=> (b.ids.length - a.ids.length) || a.address.localeCompare(b.address))
        .forEach((col) => {
          const div = document.createElement("div");
          div.className = "token";
          div.innerHTML = `
            <div class="hdr">
              <div>
                <div><strong>${col.standard || "Unknown"}</strong></div>
                <div class="small muted mono">${col.address}</div>
              </div>
              <div class="pill">${col.ids.length} token${col.ids.length>1?"s":""}</div>
            </div>`;
          div.addEventListener("click", async () => {
            const chainId = await chainIdPromise;
            renderCollectionDetail(col, wallet, chainId);
          });
          tokensEl.appendChild(div);
        });
    }

    function renderCollectionDetail(col, wallet, chainId) {
      const sel = $("selected");
      sel.textContent = "";
      $("selPill").textContent = `${col.standard || "Unknown"} • ${col.ids.length} token${col.ids.length>1?"s":""}`;

      const header = document.createElement("div");
      header.innerHTML = `
        <div style="margin-bottom:.5rem;">
          <div><strong>${col.standard || "Unknown"}</strong></div>
          <div class="small muted mono">${col.address}</div>
          <div class="small muted">Chain: ${chainId} • Owner: <span class="mono">${wallet}</span></div>
        </div>`;
      sel.appendChild(header);

      const box = document.createElement("div"); box.className = "list";
      const ids = col.ids.slice().sort((a,b) => (BigInt(a.id) > BigInt(b.id) ? 1 : -1));
      for (const {id, bal} of ids) {
        const row = document.createElement("div");
        row.className = "token";
        if (col.standard === "ERC1155") {
          row.innerHTML = `<div class="mono">id: ${id}</div><div class="small muted">balance: ${bal.toString ? bal.toString() : String(bal)}</div>`;
        } else {
          row.innerHTML = `<div class="mono">tokenId: ${id}</div>`;
        }
        box.appendChild(row);
      }
      sel.appendChild(box);
    }

    // ---------- Wire UI ----------
    window.addEventListener("DOMContentLoaded", async () => {
      if (typeof window.ethers === "undefined") {
        setError("Failed to load ethers.js. Check network/CSP or reload.");
        return;
      }
      // preload “latest” in case we need it for messaging
      try {
        const provider = getProvider();
        const latest = await provider.getBlockNumber();
        // no-op display; the scan uses latest automatically
      } catch {/* ignore */}

      $("scanBtn").addEventListener("click", (e)=>{ e.preventDefault(); scanWalletOverList(); });
      $("stopBtn").addEventListener("click", (e)=>{ e.preventDefault(); CANCEL = true; setStatus("Stopping…"); });
      $("wallet").addEventListener("keydown", (e)=>{ if (e.key === "Enter") { e.preventDefault(); scanWalletOverList(); } });
    });
  </script>
</body>
</html>
