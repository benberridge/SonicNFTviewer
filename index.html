<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sonic NFT Collection Discovery (Mint‑only, On‑chain RPC)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Load ethers v6 UMD (global window.ethers). Fallback to unpkg if needed. -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
  <script>
    if (typeof window.ethers === "undefined") {
      var s = document.createElement("script");
      s.src = "https://unpkg.com/ethers@6.11.1/dist/ethers.umd.min.js";
      document.head.appendChild(s);
    }
  </script>

  <style>
    :root { --bg:#0b0e13; --panel:#131823; --txt:#e6e9ef; --muted:#9aa3b2; --accent:#66e7ff; --danger:#ff6b6b; --line:#202636; }
    * { box-sizing: border-box; }
    body { margin:0; font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--txt); }
    .wrap { max-width: 1080px; margin: 2rem auto; padding: 0 1rem; }
    h1 { font-size:1.6rem; margin:.25rem 0 .5rem; }
    .muted { color:var(--muted); }
    .small { font-size:.9rem; }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:1rem; }
    label { display:block; font-size:.9rem; color:var(--muted); margin:.75rem 0 .25rem; }
    input[type="text"], input[type="number"] {
      width:100%; padding:.7rem .8rem; border:1px solid #263044; border-radius:10px; background:#0f1420; color:var(--txt);
    }
    .row { display:grid; grid-template-columns: repeat(5, minmax(160px, 1fr)); gap:.75rem; align-items:end; }
    .row2 { display:grid; grid-template-columns: 1fr auto auto auto auto; gap:.75rem; align-items:end; margin-top:.75rem; }
    button { padding:.75rem 1rem; background:var(--accent); color:#00242b; border:0; border-radius:10px; font-weight:600; cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .cols { display:grid; gap:1rem; grid-template-columns: 1fr 1fr; margin-top:1rem; }
    .list { min-height: 260px; border:1px dashed #2b3448; border-radius:10px; padding:.75rem; overflow:auto; }
    .error { color:var(--danger); margin-top:.5rem; white-space:pre-wrap; }
    @media (max-width: 1040px){ .row { grid-template-columns: 1fr 1fr; } .row2 { grid-template-columns: 1fr auto auto; } .cols { grid-template-columns: 1fr; } }
    .token { padding:.5rem .6rem; border:1px solid #263044; border-radius:8px; margin-bottom:.5rem; }
    .token .hdr { display:flex; align-items:center; justify-content:space-between; gap:.5rem; }
    .pill { display:inline-block; background:#0f1420; border:1px solid #263044; border-radius:999px; padding:.1rem .5rem; font-size:.75rem; color:#9fc2ca; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    progress { width: 100%; height: 10px; }
    a { color:#86f0ff; text-decoration:none; } a:hover { text-decoration:underline; }
    .kv { display:flex; flex-wrap:wrap; gap:.5rem; }
    .kv .item { background:#0f1420; border:1px solid #263044; border-radius:8px; padding:.2rem .5rem; font-size:.8rem; color:#b8c3d1; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Sonic NFT Collection Discovery</h1>
      <p class="muted small">
        Finds all **NFT contracts that have ever minted** on <strong>Sonic</strong> by scanning only mint events on-chain (no explorer API).
        RPC is fixed to <code class="mono">https://rpc.soniclabs.com</code>.  
        Optional: verify standards via ERC‑165 (<code>supportsInterface</code>).
      </p>
    </header>

    <section class="card">
      <!-- Fixed Sonic RPC (hidden) -->
      <input type="hidden" id="rpcUrl" value="https://rpc.soniclabs.com" />

      <!-- Controls -->
      <div class="row">
        <div>
          <label for="fromBlock">From block</label>
          <input id="fromBlock" class="mono" type="number" min="0" step="1" placeholder="0 (genesis)" />
        </div>
        <div>
          <label for="toBlock">To block (blank = latest)</label>
          <input id="toBlock" class="mono" type="number" min="0" step="1" placeholder="latest" />
        </div>
        <div>
          <label for="chunkSize">Initial chunk (blocks)</label>
          <input id="chunkSize" class="mono" type="number" min="1000" step="1000" value="15000" />
        </div>
        <div>
          <label for="minChunk">Min chunk (blocks)</label>
          <input id="minChunk" class="mono" type="number" min="500" step="500" value="2000" />
        </div>
        <div>
          <label for="timeoutMs">Request timeout (ms)</label>
          <input id="timeoutMs" class="mono" type="number" min="5000" step="1000" value="25000" />
        </div>
      </div>

      <div class="row2">
        <div class="kv">
          <label class="item"><input id="verify165" type="checkbox" checked /> Verify ERC‑165 (label 721/1155)</label>
          <label class="item"><input id="saveCheckpoints" type="checkbox" checked /> Save checkpoints (resume later)</label>
          <label class="item"><input id="dedupePerWindow" type="checkbox" checked /> De‑dupe per window</label>
        </div>
        <button id="startBtn">Start</button>
        <button id="stopBtn" style="background:#ffd166;color:#3a2f00;">Stop</button>
        <button id="exportBtn" style="background:#7ef29d;color:#083f2d;">Export JSON</button>
        <button id="clearBtn" style="background:#ff9aa2;color:#3a0b11;">Clear cache</button>
      </div>

      <div style="margin-top:.75rem;">
        <progress id="prog" max="100" value="0"></progress>
      </div>

      <div id="status" class="muted small" style="margin-top:.5rem;"></div>
      <div id="error" class="error" role="alert"></div>
    </section>

    <section class="cols">
      <div class="card">
        <div class="hdr" style="display:flex;align-items:center;justify-content:space-between;gap:.5rem;margin-bottom:.5rem;">
          <h3 style="margin:0;">Collections Found</h3>
          <span id="foundPill" class="pill">0</span>
        </div>
        <div id="collections" class="list muted small">No results yet</div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 .5rem 0;">Notes</h3>
        <ul class="small muted" style="margin:.2rem 0 .5rem 1rem;">
          <li>Scans only **mint events**: ERC‑721 `Transfer(from=0x00…)`, ERC‑1155 `TransferSingle/Batch(from=0x00…)`.</li>
          <li>Use **checkpoints** to split the scan over sessions; click **Start** again to resume.</li>
          <li>After scan, click **Export JSON** to download the list for your app.</li>
          <li>Optionally uncheck **ERC‑165 verification** to speed up discovery (you can label later).</li>
        </ul>
        <div id="logBox" class="list mono small" style="white-space:pre-wrap;">(log)</div>
      </div>
    </section>
  </div>

  <script>
    // ======= UI helpers =======
    const $ = (id) => document.getElementById(id);
    const setStatus = (msg) => $("status").textContent = msg ?? "";
    const setError  = (msg) => $("error").textContent  = msg ?? "";
    const clearMsgs = () => { setStatus(""); setError(""); };
    const fmt = (n) => new Intl.NumberFormat().format(n);
    const logBox = $("logBox");
    const log = (s) => { logBox.textContent += (s + "\\n"); logBox.scrollTop = logBox.scrollHeight; };
    const ZeroAddr = "0x0000000000000000000000000000000000000000";
    let CANCEL = false;

    // ======= Provider =======
    function getProvider() {
      const rpc = $("rpcUrl").value.trim();
      return new window.ethers.JsonRpcProvider(rpc);
    }

    // ======= Topics (computed once) =======
    const TOPIC_ERC721_TRANSFER = window.ethers.id("Transfer(address,address,uint256)");
    const TOPIC_ERC1155_SINGLE  = window.ethers.id("TransferSingle(address,address,address,uint256,uint256)");
    const TOPIC_ERC1155_BATCH   = window.ethers.id("TransferBatch(address,address,address,uint256[],uint256[])");
    const ZERO_TOPIC            = window.ethers.zeroPadValue(ZeroAddr, 32);

    // ======= ERC-165 (optional verification) =======
    const ERC165_ABI = ["function supportsInterface(bytes4) view returns (bool)"];
    const IFACE_721  = "0x80ac58cd";   // ERC721
    const IFACE_1155 = "0xd9b67a26";   // ERC1155

    async function verifyStandard(provider, addr) {
      try {
        const c = new window.ethers.Contract(addr, ERC165_ABI, provider);
        const [is721, is1155] = await Promise.allSettled([
          c.supportsInterface(IFACE_721),
          c.supportsInterface(IFACE_1155),
        ]);
        if (is721.status === "fulfilled" && is721.value) return "ERC721";
        if (is1155.status === "fulfilled" && is1155.value) return "ERC1155";
      } catch {}
      return "Unknown";
    }

    // ======= Adaptive getLogs with bisection & timeout =======
    function withTimeout(promise, ms) {
      return Promise.race([
        promise,
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), ms))
      ]);
    }

    async function getLogsAdaptive(provider, baseFilter, from, to, maxSpan, minSpan, timeoutMs, onProgress) {
      const out = [];
      let start = from;
      while (start <= to) {
        if (CANCEL) break;
        let span = Math.min(maxSpan, to - start + 1);
        let done = false;

        while (!done && !CANCEL) {
          const end = start + span - 1;
          const f = { ...baseFilter, fromBlock: start, toBlock: end };
          try {
            const logs = await withTimeout(provider.getLogs(f), timeoutMs);
            out.push(...logs);
            onProgress && onProgress(end);
            done = true;
          } catch (e) {
            const msg = (e?.info?.error?.message || e?.message || String(e)).toLowerCase();
            const tooBig = msg.includes("more than") || msg.includes("result set") || msg.includes("too many") || msg.includes("response size") || msg.includes("limit");
            const timed  = msg.includes("timeout") || msg.includes("timed out") || msg.includes("deadline") || msg.includes("exceeded");
            if ((tooBig || timed) && span > minSpan) {
              span = Math.max(minSpan, Math.floor(span / 2)); // bisect
              continue;
            }
            // log and skip this slice
            log(`Skipped ${start}-${end}: ${e?.message || e}`);
            onProgress && onProgress(end);
            done = true;
          }
        }
        start += Math.min(span, to - start + 1);
      }
      return out;
    }

    // ======= Checkpointing (localStorage) =======
    const CK = {
      key: "sonic_mint_discovery_v1",
      load() {
        try { return JSON.parse(localStorage.getItem(this.key) || "{}"); } catch { return {}; }
      },
      save(obj) {
        localStorage.setItem(this.key, JSON.stringify(obj));
      },
      clear() { localStorage.removeItem(this.key); }
    };

    // ======= Main scan =======
    async function runDiscovery() {
      clearMsgs(); $("collections").classList.remove("muted"); $("collections").textContent = "";
      const startBtn = $("startBtn"), stopBtn = $("stopBtn"), exportBtn = $("exportBtn");
      startBtn.disabled = true; stopBtn.disabled = false; exportBtn.disabled = true; CANCEL = false;
      const prog = $("prog"); prog.value = 0;

      if (typeof window.ethers === "undefined") { setError("ethers.js failed to load."); return; }
      const provider = getProvider();
      let latest = await provider.getBlockNumber().catch((e)=>{ setError(e?.message||"RPC error"); return null; });
      if (latest == null) { startBtn.disabled = false; stopBtn.disabled = true; return; }
      $("toBlock").placeholder = `${latest} (latest)`;

      // Inputs
      let fromBlock = parseInt($("fromBlock").value || "0", 10);
      let toBlock   = $("toBlock").value ? parseInt($("toBlock").value, 10) : latest;
      const initChunk = Math.max(1000, parseInt($("chunkSize").value || "15000", 10));
      const minChunk  = Math.max(500, parseInt($("minChunk").value || "2000", 10));
      const timeoutMs = Math.max(5000, parseInt($("timeoutMs").value || "25000", 10));
      const want165   = $("verify165").checked;
      const keepCk    = $("saveCheckpoints").checked;
      const deWindow  = $("dedupePerWindow").checked;

      if (Number.isNaN(fromBlock) || fromBlock < 0) fromBlock = 0;
      if (Number.isNaN(toBlock)   || toBlock < fromBlock) toBlock = latest;

      // State & checkpoints
      const ck = CK.load();
      const ckKey = `${fromBlock}-${toBlock}-${initChunk}-${minChunk}-${timeoutMs}`;
      const seen   = new Map( (ck[ckKey]?.seen || []).map(([a,info]) => [a, info]) ); // address -> { standard, mints }
      let progressEnd = ck[ckKey]?.progressEnd ?? (fromBlock - 1);

      function saveCk() {
        if (!keepCk) return;
        const obj = ck; // in-memory
        obj[ckKey] = {
          seen: Array.from(seen.entries()),
          progressEnd
        };
        CK.save(obj);
      }

      const totalBlocks = toBlock - fromBlock + 1;
      setStatus(`Scanning mint events… blocks ${fmt(fromBlock)} → ${fmt(toBlock)} (total ${fmt(totalBlocks)})`);
      log(`Start: from ${fromBlock} to ${toBlock} | init=${initChunk}, min=${minChunk}, timeout=${timeoutMs}ms`);

      const collectionsEl = $("collections");

      // Helper to record a contract mint
      function record(address) {
        const addr = window.ethers.getAddress(address);
        const key = addr.toLowerCase();
        const cur = seen.get(key) || { standard: "Unknown", mints: 0 };
        cur.mints += 1;
        seen.set(key, cur);
      }

      const chain = await provider.getNetwork(); const chainId = Number(chain.chainId);

      // Outer loop: process in windows of initChunk; inside, three filters per window (721 mint, 1155 single mint, 1155 batch mint)
      for (let windowStart = Math.max(fromBlock, progressEnd + 1); windowStart <= toBlock; windowStart += initChunk) {
        if (CANCEL) break;
        const windowEnd = Math.min(windowStart + initChunk - 1, toBlock);
        setStatus(`Scanning ${fmt(windowStart)} → ${fmt(windowEnd)} of ${fmt(toBlock)}…`);
        log(`Window: ${windowStart}-${windowEnd}`);

        // Optional per-window de-duplication to cut work
        const windowAddrs = new Set();

        // 1) ERC-721 mints: Transfer where from = zero
        {
          const base = { topics: [TOPIC_ERC721_TRANSFER, ZERO_TOPIC, null] };
          const logs = await getLogsAdaptive(provider, base, windowStart, windowEnd, initChunk, minChunk, timeoutMs, (end)=> {
            progressEnd = Math.max(progressEnd, end);
            prog.value = Math.min(100, Math.round(((progressEnd - fromBlock + 1) / totalBlocks) * 100));
          });
          for (const L of logs) {
            if (CANCEL) break;
            const a = L.address;
            if (deWindow) { windowAddrs.add(a); } else { record(a); }
          }
        }

        // 2) ERC-1155 Single mints: TransferSingle where from = zero (topics[2])
        {
          const base = { topics: [TOPIC_ERC1155_SINGLE, null, ZERO_TOPIC, null] };
          const logs = await getLogsAdaptive(provider, base, windowStart, windowEnd, initChunk, minChunk, timeoutMs, (end)=> {
            progressEnd = Math.max(progressEnd, end);
            prog.value = Math.min(100, Math.round(((progressEnd - fromBlock + 1) / totalBlocks) * 100));
          });
          for (const L of logs) {
            if (CANCEL) break;
            const a = L.address;
            if (deWindow) { windowAddrs.add(a); } else { record(a); }
          }
        }

        // 3) ERC-1155 Batch mints: TransferBatch where from = zero (topics[2])
        {
          const base = { topics: [TOPIC_ERC1155_BATCH, null, ZERO_TOPIC, null] };
          const logs = await getLogsAdaptive(provider, base, windowStart, windowEnd, initChunk, minChunk, timeoutMs, (end)=> {
            progressEnd = Math.max(progressEnd, end);
            prog.value = Math.min(100, Math.round(((progressEnd - fromBlock + 1) / totalBlocks) * 100));
          });
          for (const L of logs) {
            if (CANCEL) break;
            const a = L.address;
            if (deWindow) { windowAddrs.add(a); } else { record(a); }
          }
        }

        // If we were collecting deduped per window, commit them now
        if (deWindow) {
          windowAddrs.forEach(addr => record(addr));
        }

        // Persist checkpoints periodically
        saveCk();

        // Render a compact snapshot (top 200 by mint count)
        renderCollections(collectionsEl, seen, chainId);

        if (CANCEL) break;
      }

      // Optional: ERC-165 verification to label standards (run after discovery to keep log queries fast)
      if (!CANCEL && want165) {
        setStatus("Verifying standards via ERC‑165 (supportsInterface)…");
        const arr = Array.from(seen.entries());
        // modest concurrency
        const provider2 = provider;
        const limit = 8; let i = 0; let active = 0;
        const next = () => new Promise(res => {
          const work = () => {
            if (CANCEL || i >= arr.length) return res();
            while (active < limit && i < arr.length) {
              const idx = i++; active++;
              const [addr, info] = arr[idx];
              verifyStandard(provider2, addr).then(standard => {
                info.standard = standard || info.standard;
              }).catch(()=>{}).finally(()=>{
                active--;
                $("foundPill").textContent = String(seen.size);
                renderCollections(collectionsEl, seen, chainId, true);
                if (i < arr.length) work(); else res();
              });
            }
          };
          work();
        });
        await next();
      }

      if (CANCEL) {
        setStatus("Scan canceled.");
      } else {
        setStatus(`Done. Found ${fmt(seen.size)} contract${seen.size!==1?"s":""}. You can export the list now.`);
      }

      // Final save
      saveCk();

      $("foundPill").textContent = String(seen.size);
      renderCollections(collectionsEl, seen, chainId, true);

      startBtn.disabled = false; stopBtn.disabled = true; exportBtn.disabled = false;
    }

    function renderCollections(containerEl, seenMap, chainId, compact=false) {
      const items = Array.from(seenMap.entries())
        .map(([addr, info]) => ({ address: addr, standard: info.standard || "Unknown", mints: info.mints|0 }))
        .sort((a,b)=> (b.mints - a.mints) || a.address.localeCompare(b.address));

      $("foundPill").textContent = String(items.length);
      containerEl.textContent = "";
      if (items.length === 0) {
        containerEl.classList.add("muted");
        containerEl.textContent = "No results yet";
        return;
      } else {
        containerEl.classList.remove("muted");
      }

      const maxShow = compact ? Math.min(items.length, 500) : items.length;
      for (let k=0; k<maxShow; k++) {
        const it = items[k];
        const div = document.createElement("div");
        div.className = "token";
        const link = `https://sonicscan.org/token/${it.address}`;
        div.innerHTML = `
          <div class="hdr">
            <div>
              <div><strong>${it.standard}</strong> • <span class="mono">${it.address}</span></div>
              <div class="small muted"><a href="${link}" target="_blank" rel="noopener">View on SonicScan</a> • Chain ${chainId}</div>
            </div>
            <div class="pill">mints: ${fmt(it.mints)}</div>
          </div>
        `;
        containerEl.appendChild(div);
      }
      if (items.length > maxShow) {
        const more = document.createElement("div");
        more.className = "small muted";
        more.textContent = `+ ${fmt(items.length - maxShow)} more… (export to view all)`;
        containerEl.appendChild(more);
      }
    }

    // ======= Export & Clear =======
    function exportJSON() {
      const ck = CK.load();
      const out = {};
      for (const k of Object.keys(ck)) {
        // Keep only the most recent session by default; or export all—here we export the current selection on screen:
        // We’ll aggregate everything we have into a flat unique list with metadata.
        const entry = ck[k];
        if (!entry || !Array.isArray(entry.seen)) continue;
        for (const [addr, info] of entry.seen) {
          out[addr] = out[addr] || { standard: info.standard || "Unknown", mints: 0 };
          out[addr].mints += (info.mints|0);
        }
      }
      // If no cache (user didn’t enable checkpoints), try to build from current UI by scraping DOM:
      if (Object.keys(out).length === 0) {
        setError("No cached data to export. Enable checkpoints or export right after a scan.");
        return;
      }
      const arr = Object.entries(out).map(([address,info]) => ({ address, standard: info.standard, mints: info.mints|0 }))
                                     .sort((a,b)=> (b.mints - a.mints) || a.address.localeCompare(b.address));
      const blob = new Blob([JSON.stringify(arr, null, 2)], { type: "application/json" });
      const url  = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `sonic_nft_collections_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearCache() {
      CK.clear();
      $("collections").textContent = "Cache cleared.";
      $("foundPill").textContent = "0";
      log("(checkpoints cleared)");
    }

    // ======= Wire UI =======
    window.addEventListener("DOMContentLoaded", async () => {
      if (typeof window.ethers === "undefined") {
        setError("Failed to load ethers.js. Check network/CSP or reload.");
        return;
      }
      const provider = getProvider();
      try {
        const latest = await provider.getBlockNumber();
        $("toBlock").placeholder = `${latest} (latest)`;
      } catch { /* ignore */ }

      $("startBtn").addEventListener("click", (e)=>{ e.preventDefault(); runDiscovery(); });
      $("stopBtn").addEventListener("click", (e)=>{ e.preventDefault(); CANCEL = true; setStatus("Stopping…"); });
      $("exportBtn").addEventListener("click", (e)=>{ e.preventDefault(); exportJSON(); });
      $("clearBtn").addEventListener("click", (e)=>{ e.preventDefault(); clearCache(); });
    });
  </script>
</body>
</html>
