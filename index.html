<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sonic On‑chain NFT Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Primary ethers v6 UMD (global window.ethers) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
  <!-- Fallback to unpkg if primary fails -->
  <script>
    (function ensureEthersLoaded() {
      function inject(src, onload, onerror) {
        var s = document.createElement("script");
        s.src = src; s.async = false; s.onload = onload; s.onerror = onerror;
        document.head.appendChild(s);
      }
      function tryFallback() {
        if (typeof window.ethers !== "undefined") return;
        inject("https://unpkg.com/ethers@6.11.1/dist/ethers.umd.min.js",
          function(){ console.log("Loaded ethers from unpkg fallback."); },
          function(){ console.error("All ethers.js CDN fallbacks failed."); });
      }
      if (typeof window.ethers === "undefined") setTimeout(tryFallback, 100);
    })();
  </script>

  <style>
    :root { --bg:#0b0e13; --panel:#131823; --txt:#e6e9ef; --muted:#9aa3b2; --accent:#66e7ff; --danger:#ff6b6b; --line:#202636; }
    * { box-sizing: border-box; }
    body { margin:0; font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--txt); }
    .wrap { max-width: 1000px; margin: 2rem auto; padding: 0 1rem; }
    h1 { font-size:1.6rem; margin:.25rem 0 .5rem; }
    .muted { color:var(--muted); }
    .small { font-size:.9rem; }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:1rem; }
    label { display:block; font-size:.9rem; color:var(--muted); margin:.75rem 0 .25rem; }
    input[type="text"], input[type="number"] {
      width:100%; padding:.7rem .8rem; border:1px solid #263044; border-radius:10px; background:#0f1420; color:var(--txt);
    }
    .row { display:grid; grid-template-columns: 1fr auto auto; gap:.75rem; align-items:end; }
    button { padding:.75rem 1rem; background:var(--accent); color:#00242b; border:0; border-radius:10px; font-weight:600; cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .cols { display:grid; gap:1rem; grid-template-columns: 1.1fr .9fr; margin-top:1rem; }
    .list { min-height: 220px; border:1px dashed #2b3448; border-radius:10px; padding:.75rem; overflow:auto; }
    .error { color:var(--danger); margin-top:.5rem; white-space:pre-wrap; }
    @media (max-width: 960px){ .cols { grid-template-columns: 1fr; } .row { grid-template-columns: 1fr auto; } }
    .token { padding:.5rem .6rem; border:1px solid #263044; border-radius:8px; margin-bottom:.5rem; cursor:pointer; }
    .token:hover { border-color:#345; background:#0f1420; }
    .hdr { display:flex; align-items:center; justify-content:space-between; gap:.5rem; }
    .pill { display:inline-block; background:#0f1420; border:1px solid #263044; border-radius:999px; padding:.1rem .5rem; font-size:.75rem; color:#9fc2ca; }
    summary { cursor:pointer; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    progress { width: 100%; height: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Sonic On‑chain NFT Scanner</h1>
      <p class="muted small">Runs only on RPC calls (no explorer API key). Collections on the left; click to view all tokens held on the right. [1](https://onedrive.live.com?cid=DE528A5CF6C24C45&id=DE528A5CF6C24C45!s2ebcb4df77844e3faef36b12e45ff3d9)</p>
    </header>

    <section class="card">
      <!-- Fixed RPC: no user entry required -->
      <input type="hidden" id="rpcUrl" value="https://rpc.soniclabs.com" />

      <label for="wallet">Wallet address</label>
      <div class="row">
        <input id="wallet" class="mono" type="text" placeholder="0x… wallet address" autocomplete="off" />
        <button id="scanBtn">Scan</button>
        <button id="stopBtn" style="background:#ffd166;color:#3a2f00;">Stop</button>
      </div>

      <details style="margin-top:.5rem;">
        <summary class="muted small">Advanced (log scanning options)</summary>
        <div class="muted small" style="margin:.5rem 0 .25rem;">Tune these if you see timeouts or “too many results” on specific ranges.</div>
        <div style="display:grid; grid-template-columns: repeat(5, minmax(140px, 1fr)); gap:.75rem;">
          <div>
            <label for="fromBlock">From block</label>
            <input id="fromBlock" class="mono" type="number" min="0" step="1" placeholder="0 (full history)" />
          </div>
          <div>
            <label for="toBlock">To block (blank = latest)</label>
            <input id="toBlock" class="mono" type="number" min="0" step="1" placeholder="latest" />
          </div>
          <div>
            <label for="chunkSize">Initial chunk (blocks)</label>
            <input id="chunkSize" class="mono" type="number" min="1000" step="1000" value="15000" />
          </div>
          <div>
            <label for="minChunk">Min chunk (blocks)</label>
            <input id="minChunk" class="mono" type="number" min="500" step="500" value="2000" />
          </div>
          <div>
            <label for="timeoutMs">Request timeout (ms)</label>
            <input id="timeoutMs" class="mono" type="number" min="5000" step="1000" value="25000" />
          </div>
        </div>
        <div class="muted small" style="margin-top:.5rem;">
          Hint: If a specific span is heavy, the scanner will **auto‑shrink** that span until it succeeds.
        </div>
      </details>

      <div style="margin-top:.5rem;">
        <progress id="prog" max="100" value="0"></progress>
      </div>

      <div id="status" class="muted small" style="margin-top:.5rem;"></div>
      <div id="error" class="error" role="alert"></div>
    </section>

    <section class="cols">
      <div class="card">
        <div class="hdr" style="margin-bottom:.5rem;">
          <h3 style="margin:0;">Tokens Found</h3>
          <span id="foundPill" class="pill">0 collections</span>
        </div>
        <div id="tokens" class="list muted small">No results yet</div>
      </div>

      <div class="card">
        <div class="hdr" style="margin-bottom:.5rem;">
          <h3 style="margin:0;">Selected token</h3>
          <span id="selPill" class="pill">—</span>
        </div>
        <div id="selected" class="list muted small">Select a collection to view all tokens the wallet holds for it. [1](https://onedrive.live.com?cid=DE528A5CF6C24C45&id=DE528A5CF6C24C45!s2ebcb4df77844e3faef36b12e45ff3d9)</div>
      </div>
    </section>
  </div>

  <script>
    // ----------------- Utilities & UI helpers -----------------
    const $ = (id) => document.getElementById(id);
    const setStatus = (msg) => $("status").textContent = msg ?? "";
    const setError  = (msg) => $("error").textContent  = msg ?? "";
    const clearMsgs = () => { setStatus(""); setError(""); };
    const fmt = (n) => new Intl.NumberFormat().format(n);
    const mono = (s) => `<span class="mono">${s}</span>`;
    let CANCEL = false;

    function requireEthersOrShow() {
      if (typeof window.ethers === "undefined") {
        setError("Failed to load ethers.js. Check network/CSP or self‑host ethers.umd.min.js.");
        console.error("window.ethers is undefined.");
        return false;
      }
      return true;
    }

    function getProvider() {
      const rpc = $("rpcUrl").value.trim();
      return new window.ethers.JsonRpcProvider(rpc);
    }

    const iface1155 = new window.ethers.Interface([
      "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)",
      "event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)"
    ]);

    const TOPIC_ERC721_TRANSFER = window.ethers.id("Transfer(address,address,uint256)");
    const TOPIC_ERC1155_SINGLE  = window.ethers.id("TransferSingle(address,address,address,uint256,uint256)");
    const TOPIC_ERC1155_BATCH   = window.ethers.id("TransferBatch(address,address,address,uint256[],uint256[])");

    const toTopicAddress = (addr) => window.ethers.zeroPadValue(window.ethers.getAddress(addr), 32);

    // ----------------- Adaptive getLogs -----------------
    async function getLogsAdaptive(provider, baseFilter, from, to, maxSpan, minSpan, timeoutMs, onProgress) {
      const logs = [];
      let start = from;
      while (start <= to) {
        if (CANCEL) break;
        let span = Math.min(maxSpan, to - start + 1);
        let fetched = false;

        while (!fetched) {
          if (CANCEL) break;
          const end = start + span - 1;
          const filter = { ...baseFilter, fromBlock: start, toBlock: end };

          try {
            const result = await withTimeout(provider.getLogs(filter), timeoutMs);
            logs.push(...result);
            fetched = true;
            onProgress && onProgress(end);
          } catch (e) {
            const msg = (e && (e.info?.error?.message || e.message || String(e))).toLowerCase();
            const tooBig = msg.includes("more than") || msg.includes("too many") || msg.includes("response size") || msg.includes("limit");
            const timed  = msg.includes("timeout") || msg.includes("timed out") || msg.includes("exceeded") || msg.includes("deadline");
            if ((tooBig || timed) && span > minSpan) {
              span = Math.max(minSpan, Math.floor(span / 2));
              // retry with smaller span
              continue;
            } else {
              console.warn("getLogs error on", {start, end, msg:e});
              // push error info but move on to avoid stalling whole scan
              fetched = true; // skip this subrange
              onProgress && onProgress(end);
            }
          }
        }

        start += span;
      }
      return logs;
    }

    function withTimeout(promise, ms) {
      return Promise.race([
        promise,
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), ms))
      ]);
    }

    // ----------------- Scan engine (pure logs → balances) -----------------
    async function scanWalletNfts() {
      clearMsgs();
      if (!requireEthersOrShow()) return;

      const walletRaw = $("wallet").value.trim();
      if (!walletRaw) return setError("Please enter a wallet address.");
      let wallet;
      try { wallet = window.ethers.getAddress(walletRaw); }
      catch { return setError("That doesn’t look like a valid address."); }

      const provider = getProvider();
      const latest = await provider.getBlockNumber();

      // Read options
      let fromBlock = parseInt($("fromBlock").value || "0", 10);
      let toBlock   = $("toBlock").value ? parseInt($("toBlock").value, 10) : latest;
      const initChunk = Math.max(1000, parseInt($("chunkSize").value || "15000", 10));
      const minChunk  = Math.max(500,  parseInt($("minChunk").value  || "2000", 10));
      const timeoutMs = Math.max(5000, parseInt($("timeoutMs").value || "25000", 10));

      if (Number.isNaN(fromBlock) || fromBlock < 0) fromBlock = 0;
      if (Number.isNaN(toBlock) || toBlock < fromBlock) toBlock = latest;

      // Reset UI
      CANCEL = false;
      const scanBtn = $("scanBtn"), stopBtn = $("stopBtn");
      scanBtn.disabled = true; stopBtn.disabled = false;
      $("tokens").textContent = ""; $("tokens").classList.remove("muted");
      $("selected").textContent = "Scanning…";
      $("selPill").textContent = "—";
      $("foundPill").textContent = "0 collections";
      const prog = $("prog"); prog.value = 0;

      const chain = await provider.getNetwork();
      const chainId = Number(chain.chainId);

      // Balance maps constructed purely from logs:
      // For ERC‑721 → Map(contract => Map(tokenId => integer netFlow))
      // For ERC‑1155 -> Map(contract => Map(id => BigInt balance))
      const erc721 = new Map();
      const erc1155 = new Map();

      const walletTopic = toTopicAddress(wallet);
      const totalBlocks = toBlock - fromBlock + 1;
      let processedEnd = fromBlock - 1;

      setStatus(`Scanning chain ${chainId} • blocks ${fmt(fromBlock)} → ${fmt(toBlock)} (total ${fmt(totalBlocks)})…`);

      // We scan per initial chunk window, but each window splits adaptively inside getLogsAdaptive.
      for (let windowStart = fromBlock; windowStart <= toBlock; windowStart += initChunk) {
        if (CANCEL) break;
        const windowEnd = Math.min(windowStart + initChunk - 1, toBlock);
        setStatus(`Scanning logs ${fmt(windowStart)} → ${fmt(windowEnd)} of ${fmt(toBlock)}…`);

        // For each window, pull 6 filters sequentially (stable for strict RPCs)
        const filters = [
          { topics: [TOPIC_ERC721_TRANSFER, walletTopic, null] }, // 721 from wallet
          { topics: [TOPIC_ERC721_TRANSFER, null, walletTopic] }, // 721 to wallet
          { topics: [TOPIC_ERC1155_SINGLE,  null, walletTopic, null] }, // 1155 single from wallet
          { topics: [TOPIC_ERC1155_SINGLE,  null, null, walletTopic] }, // 1155 single to wallet
          { topics: [TOPIC_ERC1155_BATCH,   null, walletTopic, null] }, // 1155 batch from wallet
          { topics: [TOPIC_ERC1155_BATCH,   null, null, walletTopic] }  // 1155 batch to wallet
        ];

        for (const base of filters) {
          if (CANCEL) break;
          const logs = await getLogsAdaptive(
            provider,
            base,
            windowStart,
            windowEnd,
            initChunk,   // max span equals initial chunk for stability inside window
            minChunk,
            timeoutMs,
            (endDone) => {
              processedEnd = Math.max(processedEnd, endDone);
              prog.value = Math.min(100, Math.round(((processedEnd - fromBlock + 1) / totalBlocks) * 100));
            }
          );

          // Reduce logs → balances
          for (const log of logs) {
            if (CANCEL) break;

            const addr = window.ethers.getAddress(log.address);
            const t0 = log.topics[0];

            if (t0 === TOPIC_ERC721_TRANSFER) {
              // topics[1]=from, [2]=to, [3]=tokenId
              const from = window.ethers.getAddress("0x" + log.topics[1].slice(26));
              const to   = window.ethers.getAddress("0x" + log.topics[2].slice(26));
              const tokenId = window.ethers.toBigInt(log.topics[3]).toString();

              let map = erc721.get(addr);
              if (!map) { map = new Map(); erc721.set(addr, map); }
              const cur = map.get(tokenId) || 0;
              if (from === wallet) map.set(tokenId, cur - 1);
              if (to   === wallet) map.set(tokenId, (map.get(tokenId) || 0) + 1);
            }
            else if (t0 === TOPIC_ERC1155_SINGLE) {
              const parsed = iface1155.decodeEventLog("TransferSingle", log.data, log.topics);
              const from = window.ethers.getAddress(parsed.from);
              const to   = window.ethers.getAddress(parsed.to);
              const id   = window.ethers.toBigInt(parsed.id).toString();
              const val  = window.ethers.toBigInt(parsed.value);

              let map = erc1155.get(addr);
              if (!map) { map = new Map(); erc1155.set(addr, map); }
              const cur = map.get(id) || 0n;
              let next = cur;
              if (from === wallet) next -= val;
              if (to   === wallet) next += val;
              map.set(id, next);
            }
            else if (t0 === TOPIC_ERC1155_BATCH) {
              const parsed = iface1155.decodeEventLog("TransferBatch", log.data, log.topics);
              const from = window.ethers.getAddress(parsed.from);
              const to   = window.ethers.getAddress(parsed.to);
              const ids  = parsed.ids.map(x => window.ethers.toBigInt(x).toString());
              const vals = parsed.values.map(x => window.ethers.toBigInt(x));

              let map = erc1155.get(addr);
              if (!map) { map = new Map(); erc1155.set(addr, map); }
              for (let i = 0; i < ids.length; i++) {
                const id = ids[i], val = vals[i];
                const cur = map.get(id) || 0n;
                let next = cur;
                if (from === wallet) next -= val;
                if (to   === wallet) next += val;
                map.set(id, next);
              }
            }
          }
        }
      }

      if (CANCEL) {
        setStatus("Scan canceled.");
        $("selPill").textContent = "—";
        $("foundPill").textContent = "—";
        scanBtn.disabled = false; stopBtn.disabled = true;
        return;
      }

      // Build collections list from balances (current holdings only)
      const collections = [];

      // ERC‑721
      for (const [contract, tokenMap] of erc721.entries()) {
        const ownedIds = [];
        for (const [id, net] of tokenMap.entries()) {
          if (net > 0) ownedIds.push(id);
        }
        if (ownedIds.length) {
          collections.push({
            address: contract,
            standard: "ERC721",
            ids: ownedIds.sort((a,b)=> (BigInt(a) > BigInt(b) ? 1 : -1))
          });
        }
      }
      // ERC‑1155
      for (const [contract, idMap] of erc1155.entries()) {
        const owned = [];
        for (const [id, bal] of idMap.entries()) {
          if (bal > 0n) owned.push({ id, bal });
        }
        if (owned.length) {
          owned.sort((a,b)=> (BigInt(a.id) > BigInt(b.id) ? 1 : -1));
          collections.push({
            address: contract,
            standard: "ERC1155",
            ids: owned   // {id, bal}
          });
        }
      }

      // Sort collections by count desc
      collections.sort((a,b) => (b.ids.length - a.ids.length) || a.address.localeCompare(b.address));

      // Render left list
      const tokensEl = $("tokens");
      tokensEl.textContent = "";
      if (collections.length === 0) {
        tokensEl.classList.add("muted");
        tokensEl.textContent = "No NFTs found for this wallet in the scanned block range.";
        $("foundPill").textContent = "0 collections";
        $("selected").textContent = "—";
        $("selPill").textContent = "—";
      } else {
        $("foundPill").textContent = `${collections.length} collection${collections.length>1?"s":""}`;
        for (const col of collections) {
          const div = document.createElement("div");
          div.className = "token";
          div.innerHTML = `
            <div style="display:flex; align-items:center; justify-content:space-between; gap:.5rem;">
              <div>
                <div><strong>${mono(col.address)}</strong></div>
                <div class="small muted">${col.standard}</div>
              </div>
              <div class="pill">${col.ids.length} token${col.ids.length>1?"s":""}</div>
            </div>`;
          div.addEventListener("click", () => renderCollectionDetail(col, wallet, chainId));
          tokensEl.appendChild(div);
        }
      }

      setStatus(`Scan complete. Chain ${chainId} • Blocks processed: ${fmt(toBlock - fromBlock + 1)}.`);
      $("selPill").textContent = "—";
      scanBtn.disabled = false; stopBtn.disabled = true;
    }

    function renderCollectionDetail(col, wallet, chainId) {
      const sel = $("selected");
      sel.textContent = "";
      $("selPill").textContent = `${col.standard} • ${col.ids.length} token${col.ids.length>1?"s":""}`;
      const header = document.createElement("div");
      header.innerHTML = `
        <div style="margin-bottom:.5rem;">
          <div><strong>Collection</strong> ${mono(col.address)}</div>
          <div class="small muted">Chain: ${chainId} • Owner: ${mono(wallet)}</div>
        </div>`;
      sel.appendChild(header);

      const box = document.createElement("div"); box.className = "list";
      if (col.standard === "ERC721") {
        col.ids.forEach(id => {
          const row = document.createElement("div");
          row.className = "token";
          row.innerHTML = `<div class="mono">tokenId: ${id}</div>`;
          box.appendChild(row);
        });
      } else {
        col.ids.forEach(({id, bal}) => {
          const row = document.createElement("div");
          row.className = "token";
          row.innerHTML = `<div class="mono">id: ${id}</div><div class="small muted">balance: ${bal.toString()}</div>`;
          box.appendChild(row);
        });
      }
      sel.appendChild(box);
    }

    // ----------------- Wire UI -----------------
    window.addEventListener("DOMContentLoaded", async () => {
      if (!requireEthersOrShow()) return;

      const provider = getProvider();
      try {
        const latest = await provider.getBlockNumber();
        $("toBlock").placeholder = `${latest} (latest)`;
      } catch (_) { /* ignore */ }

      $("scanBtn").addEventListener("click", (e) => { e.preventDefault(); scanWalletNfts(); });
      $("stopBtn").addEventListener("click", (e) => { e.preventDefault(); CANCEL = true; });
      $("wallet").addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); scanWalletNfts(); } });
    });
  </script>
</body>
</html>
